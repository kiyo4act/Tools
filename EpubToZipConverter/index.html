<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0">
  <meta name="description"
        content="EPUBå½¢å¼ã®ãƒãƒ³ã‚¬ãªã©ã‹ã‚‰ç”»åƒã‚’æŠ½å‡ºã—ã€é€£ç•ªä»˜ãZIPãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›ã™ã‚‹ãƒ„ãƒ¼ãƒ«ã€‚è¤‡æ•°ã®EPUBãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€æ‹¬å‡¦ç†ã«å¯¾å¿œã€‚">
  <meta name="last-updated"
        content="2025-08-22">
  <meta name="category"
        content="å¤‰æ›ãƒ»æŠ½å‡º">
  <meta name="version"
        content="1">
  <title>EPUBã®ç”»åƒã‚’ã¾ã¨ã‚ã¦ZIPã«å¤‰æ›ã™ã‚‹ãƒ„ãƒ¼ãƒ«</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- JSZipãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã¿ã¾ã™ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body {
      font-family: 'Inter', 'Noto Sans JP', sans-serif;
    }

    .drop-zone {
      transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
    }

    .drop-zone-over {
      background-color: #e0f2fe;
      border-color: #0284c7;
    }

    .loader {
      border-top-color: #3498db;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body class="bg-slate-100 text-slate-800 flex items-center justify-center min-h-screen p-4">

  <div class="w-full max-w-2xl bg-white rounded-xl shadow-lg p-6 md:p-8">
    <div class="text-center mb-6">
      <h1 class="text-2xl md:text-3xl font-bold text-slate-900">EPUBã®ç”»åƒã‚’ã¾ã¨ã‚ã¦ZIPã«å¤‰æ›ã™ã‚‹ãƒ„ãƒ¼ãƒ«</h1>
      <p class="text-slate-500 mt-2">EPUBå½¢å¼ã®ãƒãƒ³ã‚¬ãªã©ã‹ã‚‰ç”»åƒã‚’æŠ½å‡ºã—ã€ZIPãƒ•ã‚¡ã‚¤ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚</p>
    </div>

    <!-- ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã®æ³¨æ„æ›¸ã -->
    <div class="bg-sky-50 border border-sky-200 rounded-lg p-4 mb-6">
      <div class="flex items-start">
        <svg xmlns="http://www.w3.org/2000/svg"
             class="w-5 h-5 text-sky-600 mt-0.5 mr-2 flex-shrink-0"
             fill="none"
             viewBox="0 0 24 24"
             stroke="currentColor"
             stroke-width="2">
          <path stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
        </svg>
        <div class="text-sm">
          <p class="font-semibold text-sky-900 mb-1">ğŸ”’ ã™ã¹ã¦ã®å‡¦ç†ã¯ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å®Œçµã—ã¾ã™</p>
          <p class="text-sky-700">ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä¸€åˆ‡ã‚µãƒ¼ãƒãƒ¼ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã›ã‚“ã€‚ã™ã¹ã¦ã®å¤‰æ›å‡¦ç†ã¯ã‚ãªãŸã®ãƒ‡ãƒã‚¤ã‚¹ä¸Šã§å®‰å…¨ã«å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãŒå®Œå…¨ã«ä¿è­·ã•ã‚Œã¾ã™ã€‚</p>
        </div>
      </div>
    </div>

    <!-- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚¨ãƒªã‚¢ -->
    <div id="dropZone"
         class="drop-zone border-2 border-dashed border-slate-300 rounded-lg p-8 text-center cursor-pointer bg-slate-50 hover:bg-slate-100">
      <input type="file"
             id="fileInput"
             class="hidden"
             accept=".epub"
             multiple>
      <div class="flex flex-col items-center">
        <svg xmlns="http://www.w3.org/2000/svg"
             class="w-12 h-12 text-slate-400 mb-4"
             fill="none"
             viewBox="0 0 24 24"
             stroke="currentColor"
             stroke-width="1.5">
          <path stroke-linecap="round"
                stroke-linejoin="round"
                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
        </svg>
        <p class="font-semibold text-slate-700">ã“ã“ã«EPUBãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</p>
        <p class="text-slate-500 text-sm mt-1">ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠï¼ˆè¤‡æ•°å¯ï¼‰</p>
      </div>
    </div>

    <!-- ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚¨ãƒªã‚¢ -->
    <div id="downloadOptionsContainer"
         class="mt-6 hidden">
      <div class="bg-slate-50 p-4 rounded-lg border border-slate-200">
        <div class="flex items-center justify-center mb-4">
          <input id="downloadIndividuallyCheckbox"
                 type="checkbox"
                 class="h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500">
          <label for="downloadIndividuallyCheckbox"
                 class="ml-2 block text-sm text-slate-900">å€‹åˆ¥ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãã‚Œãã‚Œãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹</label>
        </div>
        <button id="downloadButton"
                class="w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:bg-slate-400 disabled:cursor-wait">
          <span id="download-text">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹</span>
          <span id="download-loader"
                class="hidden">å‡¦ç†ä¸­...</span>
        </button>
      </div>
    </div>

    <!-- å‡¦ç†çŠ¶æ³è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
    <div id="status"
         class="mt-6 text-center hidden">
      <p id="overallStatusText"
         class="text-slate-600 font-medium mb-2"></p>
      <div class="flex items-center justify-center">
        <div id="loader"
             class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-6 w-6 mr-3"></div>
        <p id="statusText"
           class="text-slate-600"></p>
      </div>
      <div id="progressBarContainer"
           class="w-full bg-slate-200 rounded-full h-2.5 mt-4 hidden">
        <div id="progressBar"
             class="bg-sky-500 h-2.5 rounded-full"
             style="width: 0%"></div>
      </div>
    </div>

    <!-- çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
    <div id="resultsList"
         class="mt-6 space-y-3">
      <!-- å®Œäº†ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
    </div>
  </div>

  <script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const statusDiv = document.getElementById('status');
    const overallStatusText = document.getElementById('overallStatusText');
    const statusText = document.getElementById('statusText');
    const loader = document.getElementById('loader');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');
    const resultsList = document.getElementById('resultsList');
    const downloadOptionsContainer = document.getElementById('downloadOptionsContainer');

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drop-zone-over'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drop-zone-over'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('drop-zone-over');
      if (e.dataTransfer.files.length > 0) processFiles(e.dataTransfer.files);
    });
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) processFiles(e.target.files);
    });

    // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é †æ¬¡å‡¦ç†ã™ã‚‹ãƒ¡ã‚¤ãƒ³é–¢æ•°
    async function processFiles(files) {
      const epubFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.epub'));
      if (epubFiles.length === 0) {
        alert('æœ‰åŠ¹ãªEPUBãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        return;
      }

      resetUI();
      statusDiv.classList.remove('hidden');

      const successfulZips = [];

      for (let i = 0; i < epubFiles.length; i++) {
        const file = epubFiles[i];
        overallStatusText.textContent = `å‡¦ç†ä¸­ (${i + 1} / ${epubFiles.length}): ${file.name}`;
        resetFileProgress();

        const result = await handleFile(file);

        if (result.status === 'success') {
          successfulZips.push({ fileName: result.fileName, blob: result.blob });
          addResultMessage(file.name, result.message, 'success');
        } else {
          addResultMessage(file.name, result.message, 'error');
        }
      }

      statusDiv.classList.add('hidden');

      if (successfulZips.length > 0) {
        overallStatusText.textContent = `ã™ã¹ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚(${successfulZips.length}ä»¶æˆåŠŸ)`;
        setupDownloadOptions(successfulZips);
      } else {
        overallStatusText.textContent = 'ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
      }
    }

    // å€‹åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†é–¢æ•°
    async function handleFile(file) {
      try {
        statusText.textContent = 'EPUBãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...';
        const zip = await JSZip.loadAsync(file);

        statusText.textContent = 'æ§‹é€ ã‚’è§£æä¸­...';
        const containerXmlPath = 'META-INF/container.xml';
        if (!zip.files[containerXmlPath]) throw new Error('META-INF/container.xml ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        const containerXmlStr = await zip.files[containerXmlPath].async('string');
        const parser = new DOMParser();
        const containerDoc = parser.parseFromString(containerXmlStr, 'application/xml');
        const opfPath = containerDoc.getElementsByTagName('rootfile')[0].getAttribute('full-path');
        const opfBasePath = opfPath.includes('/') ? opfPath.substring(0, opfPath.lastIndexOf('/') + 1) : '';

        statusText.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’è§£æä¸­...';
        const opfStr = await zip.files[opfPath].async('string');
        const opfDoc = parser.parseFromString(opfStr, 'application/xml');
        const manifestItems = opfDoc.getElementsByTagName('manifest')[0].getElementsByTagName('item');
        const spineItems = opfDoc.getElementsByTagName('spine')[0].getElementsByTagName('itemref');
        const manifestMap = new Map();
        for (const item of manifestItems) {
          manifestMap.set(item.getAttribute('id'), { href: item.getAttribute('href'), mediaType: item.getAttribute('media-type') });
        }

        statusText.textContent = 'ãƒšãƒ¼ã‚¸ã®é †ç•ªã‚’ç‰¹å®šä¸­...';
        const orderedHtmlFiles = [];
        for (const item of spineItems) {
          const id = item.getAttribute('idref');
          const manifestItem = manifestMap.get(id);
          if (manifestItem && manifestItem.mediaType.includes('xhtml')) {
            orderedHtmlFiles.push(opfBasePath + manifestItem.href);
          }
        }

        statusText.textContent = 'ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡ºä¸­...';
        const orderedImagePaths = [];
        const seenImages = new Set();
        for (const htmlPath of orderedHtmlFiles) {
          if (!zip.files[htmlPath]) continue;
          const htmlStr = await zip.files[htmlPath].async('string');
          const htmlDoc = parser.parseFromString(htmlStr, 'text/html');
          const images = htmlDoc.querySelectorAll('img, image');
          const htmlBasePath = htmlPath.includes('/') ? htmlPath.substring(0, htmlPath.lastIndexOf('/') + 1) : '';
          for (const img of images) {
            let src = img.getAttribute('src') || img.getAttribute('xlink:href');
            if (src) {
              const url = new URL(src, `file:///${htmlBasePath}`);
              const fullPath = decodeURIComponent(url.pathname.substring(1));
              if (!seenImages.has(fullPath) && zip.files[fullPath]) {
                orderedImagePaths.push(fullPath);
                seenImages.add(fullPath);
              }
            }
          }
        }

        if (orderedImagePaths.length === 0) throw new Error('ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');

        statusText.textContent = 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆä¸­...';
        loader.classList.add('hidden');
        progressBarContainer.classList.remove('hidden');
        const outputZip = new JSZip();
        const totalImages = orderedImagePaths.length;
        const padLength = String(totalImages).length;
        for (let i = 0; i < totalImages; i++) {
          const imagePath = orderedImagePaths[i];
          const fileExtension = imagePath.split('.').pop();
          const newFileName = String(i + 1).padStart(padLength, '0') + '.' + fileExtension;
          const imageData = await zip.files[imagePath].async('blob');
          outputZip.file(newFileName, imageData);
          progressBar.style.width = `${((i + 1) / totalImages) * 100}%`;
        }

        const zipBlob = await outputZip.generateAsync({ type: 'blob' });
        const zipFileName = `${file.name.replace(/\.epub$/i, '')}.zip`;
        return { status: 'success', fileName: zipFileName, blob: zipBlob, message: `${totalImages}å€‹ã®ç”»åƒã‚’æŠ½å‡º` };

      } catch (error) {
        console.error(`Error processing ${file.name}:`, error);
        return { status: 'error', message: `ã‚¨ãƒ©ãƒ¼: ${error.message}` };
      }
    }

    // çµæœãƒªã‚¹ãƒˆã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã™ã‚‹é–¢æ•°
    function addResultMessage(fileName, message, status) {
      const bgColor = status === 'success' ? 'bg-green-50' : 'bg-red-50';
      const borderColor = status === 'success' ? 'border-green-200' : 'border-red-200';
      const titleColor = status === 'success' ? 'text-green-800' : 'text-red-800';
      const textColor = status === 'success' ? 'text-green-600' : 'text-red-600';

      const resultEl = document.createElement('div');
      resultEl.className = `${bgColor} border ${borderColor} rounded-lg p-4`;
      resultEl.innerHTML = `
                <div>
                    <p class="font-semibold ${titleColor} truncate">${fileName}</p>
                    <p class="text-sm ${textColor}">${message}</p>
                </div>
            `;
      resultsList.appendChild(resultEl);
    }

    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã™ã‚‹é–¢æ•°
    function setupDownloadOptions(successfulZips) {
      downloadOptionsContainer.classList.remove('hidden');
      const button = document.getElementById('downloadButton');
      const checkbox = document.getElementById('downloadIndividuallyCheckbox');

      // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã¦é‡è¤‡ã‚’é˜²ã
      const newButton = button.cloneNode(true);
      button.parentNode.replaceChild(newButton, button);

      newButton.addEventListener('click', async () => {
        newButton.disabled = true;
        const downloadText = newButton.querySelector('#download-text');
        const downloadLoader = newButton.querySelector('#download-loader');
        downloadText.classList.add('hidden');
        downloadLoader.classList.remove('hidden');

        if (checkbox.checked) {
          // å€‹åˆ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          downloadLoader.textContent = 'å€‹åˆ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...';
          for (const item of successfulZips) {
            triggerDownload(item.blob, item.fileName);
            await new Promise(resolve => setTimeout(resolve, 300)); // é€£ç¶šãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®ãŸã‚ã®é…å»¶
          }
        } else {
          // ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          downloadLoader.textContent = 'ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆä¸­...';
          const masterZip = new JSZip();
          for (const item of successfulZips) {
            masterZip.file(item.fileName, item.blob);
          }
          const masterBlob = await masterZip.generateAsync({ type: 'blob' });
          triggerDownload(masterBlob, 'converted_epubs.zip');
        }

        newButton.disabled = false;
        downloadText.classList.remove('hidden');
        downloadLoader.classList.add('hidden');
      });
    }

    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function triggerDownload(blob, fileName) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // UIã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°
    function resetUI() {
      resultsList.innerHTML = '';
      downloadOptionsContainer.classList.add('hidden');
      overallStatusText.textContent = '';
      statusDiv.classList.add('hidden');
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®é€²æ—è¡¨ç¤ºã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°
    function resetFileProgress() {
      statusText.textContent = '';
      loader.classList.remove('hidden');
      progressBarContainer.classList.add('hidden');
      progressBar.style.width = '0%';
    }
  </script>
</body>

</html>